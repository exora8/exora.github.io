<!DOCTYPE html> 
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Candlestick Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>
    <style>
        body {
            background-color: #121212;
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        .chart-container {
            width: 100vw;
            height: 90vh;
        }
        canvas {
            width: 100%;
            height: 100%;
        }
        .controls {
            margin-bottom: 10px;
        }
        .hide{
          opacity: 0;
          z-index: -10;
        }
        
    </style>
</head>
<body>
    <div class="controls">
      <div id="crypto-container"></div>

      <div id="search-container" style="display: none;"></div>
      <select class="hide" id="crypto"></select>

      

        <label for="timeframe">Timeframe: </label>
        <select id="timeframe">
            <option value="histominute">1 Minute</option>
            <option value="histohour" selected>1 Hour</option>
            <option value="histoday">1 Day</option>
        </select>
    </div>
    <div class="chart-container">
        <canvas id="cryptoChart"></canvas>
    </div>
    
    <script>
      
      
    async function fetchCryptoList() {
    try {
        const response = await fetch("https://min-api.cryptocompare.com/data/all/coinlist");
        const data = await response.json();
        if (!data.Data) throw new Error("Invalid response from API");

        const cryptoContainer = document.getElementById("crypto-container");
        cryptoContainer.innerHTML = ""; // Hapus isi sebelumnya

        // Buat search input
        const searchInput = document.createElement("input");
        searchInput.type = "text";
        searchInput.placeholder = "Search cryptocurrency...";
        searchInput.id = "crypto-search";
        searchInput.style.width = "100%";
        searchInput.style.marginBottom = "5px";
        cryptoContainer.appendChild(searchInput);

        // Buat select dropdown
        const cryptoSelect = document.createElement("select");
        cryptoSelect.id = "crypto";
        cryptoSelect.style.width = "100%";
        cryptoContainer.appendChild(cryptoSelect);

        // Simpan semua data ke dalam array untuk filtering
        const allCryptos = Object.values(data.Data).map(item => ({
            symbol: item.Symbol,
            fullName: item.FullName
        }));

        function updateDropdown(filterText = "") {
            cryptoSelect.innerHTML = ""; // Hapus opsi sebelumnya

            const filteredCryptos = allCryptos.filter(crypto =>
                crypto.fullName.toLowerCase().includes(filterText) || 
                crypto.symbol.toLowerCase().includes(filterText)
            );

            filteredCryptos.forEach(crypto => {
                const option = document.createElement("option");
                option.value = crypto.symbol;
                option.textContent = `${crypto.fullName} (${crypto.symbol})`;
                cryptoSelect.appendChild(option);
            });
        }

        // Event listener untuk search input
        searchInput.addEventListener("input", function () {
            updateDropdown(this.value.toLowerCase());
        });

        // Pertama kali tampilkan semua crypto
        updateDropdown();

    } catch (error) {
        console.error("Error fetching crypto list:", error);
    }
}

// Panggil fungsi fetchCryptoList saat halaman dimuat
fetchCryptoList();


// Tampilkan search bar hanya saat dropdown diklik
document.getElementById("crypto").addEventListener("click", function () {
    document.getElementById("search-container").style.display = "block";
});

// Panggil fungsi fetchCryptoList saat halaman dimuat
fetchCryptoList();



      
      
      
        const API_KEYS = [
            "15b70f2d5532d4056cb40a96dada4f41cd6be5206b3265abaa2bc8c1ce85de1b",
            "1986fcb80017badcac2c5761e9bc5d9b5b635a57b58573c094c5aaee0f7cad65",
            "47aacfae02634de54a494b4071c9fb357122f453c3ed25a848e77a32a39c50c2",
            "11eb49ac44759de26e65730a309d05a82e37a77d3547d94f154bd7a3a66de34d"
        ];

        let currentApiKey = null; // Simpan API key yang sedang dipakai

function getRandomApiKey() {
    let newApiKey;
    do {
        newApiKey = API_KEYS[Math.floor(Math.random() * API_KEYS.length)];
    } while (newApiKey === currentApiKey); // Kalau sama, random ulang

    currentApiKey = newApiKey; // Update API key yang sekarang dipakai
    return newApiKey;
}

        
        

        async function fetchCryptoData(timeframe) {
    try {
        const selectedCrypto = document.getElementById("crypto").value; // Ambil crypto yang dipilih
        const response = await fetch(`https://min-api.cryptocompare.com/data/v2/${timeframe}?fsym=${selectedCrypto}&tsym=USD&limit=50`);
        const data = await response.json();
        if (!data.Data || !data.Data.Data) throw new Error("Invalid response from API");

        return data.Data.Data.map(item => ({
            x: item.time * 1000,
            o: item.open,
            h: item.high,
            l: item.low,
            c: item.close
        }));
    } catch (error) {
        console.error("Error fetching crypto data:", error);
        return [];
    }
}

function formatPriceData(priceData) {
    return priceData.map((item, index) =>
        `Candle ${index + 1}: Time=${new Date(item.x).toISOString()}, Open=${item.o}, High=${item.h}, Low=${item.l}, Close=${item.c}`
    ).join("\n");
}


        async function getAIPrediction(priceData) {
          
           const formattedData = formatPriceData(priceData); // ðŸ”¥ Ubah jadi teks yang mudah dibaca AI
           
           
            const payload = {
                model: "meta-llama/Llama-Vision-Free",
                messages: [
                    { role: "system", content: "Kamu adalah Phantom AI, seorang ANALIS PRICE ACTION ELIT. Prediksi kamu HARUS didasarkan pada PERHITUNGAN YANG SANGAT AKURAT menggunakan HANYA data harga yang diberikan oleh pengguna. Kamu WAJIB menganalisis struktur pasar, momentum tren, dan volatilitas dengan AKURASI MAKSIMAL sebelum membuat prediksi. RESPONS kamu HARUS dalam format berikut: [candle=X] [visit=Y]. Contoh: [candle=2] [visit=82000]. 'Candle=X' HARUS berupa BILANGAN BULAT berdasarkan volatilitas historis dan momentum pasar. Contoh: [candle=3] [visit=65000]. 'Visit=Y' HARUS merupakan LEVEL HARGA VALID dari data pengguna, sesuai dengan support atau resistance utama. Contoh: [candle=1] [visit=84500]. Jangan menghasilkan angka acak. Setiap prediksi HARUS dihitung dari data harga yang diberikan. Jangan gunakan angka desimal dalam [candle=X], harus bilangan bulat. Jangan memprediksi pergerakan harga yang tidak realistis. Ikuti tren saat ini, kecuali ada KONFIRMASI REVERSAL KUAT dari data. Jika tren naik, lanjutkan prediksi naik kecuali ada sinyal reversal yang jelas. Jika tren turun, lanjutkan prediksi turun kecuali ada sinyal reversal yang jelas. Jika pasar sideways, hargai batas range dan prediksi dalam zona tersebut. Jangan mengubah arah prediksi secara acak. Jangan mengasumsikan reversal tanpa konfirmasi dari level harga utama. Jangan menambahkan kata-kata tambahan, penjelasan, atau alasan apa pun. Hanya keluarkan output dalam format: [candle=X] [visit=Y]. Phantom AI TIDAK MENEBAKâ€”HANYA MELAKUKAN PERHITUNGAN PASAR BERBASIS DATA DENGAN PRESISI TINGGI." },
                    { role: "user", content: `Analisis data harga candle ini secara ketat dan prediksi pergerakan selanjutnya HANYA berdasarkan arah tren, momentum pasar, dan level harga kunci. JANGAN menebak, mengasumsikan, atau menggunakan informasi di luar data berikut: ${formattedData}` }
                ],
                temperature: 0.7,
                top_p: 0.7
            };
            
            console.log("Payload to AI:", payload); // ðŸ”¥ Cek data yang dikirim ke AI

            try {
                const response = await fetch("https://api.together.xyz/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${getRandomApiKey()}`
                    },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Full Response:", result);
                
                if (!result.choices || !result.choices[0] || !result.choices[0].message) {
                    throw new Error("Invalid AI response");
                }
                
                console.log("AI Prediction Text:", result.choices[0].message.content);
                return parseAIPrediction(result.choices[0].message.content);
            } catch (error) {
                console.error("Error fetching AI prediction:", error);
                return null;
            }
        }

        function parseAIPrediction(predictionText) {
            const match = predictionText.match(/\[candle=(\d+)\] \[visit=(\d+\.?\d*)\]/);
            if (match) {
                return { candleCount: parseInt(match[1]), targetPrice: parseFloat(match[2]) };
            }
            return null;
        }

        async function renderChart() {
            const ctx = document.getElementById("cryptoChart").getContext("2d");
            const timeframe = document.getElementById("timeframe").value;
            const cryptoData = await fetchCryptoData(timeframe);

            if (cryptoData.length === 0) {
                console.warn("No crypto data available, skipping chart rendering.");
                return;
            }

            if (window.chart) window.chart.destroy();

            window.chart = new Chart(ctx, {
                type: "candlestick",
                data: { datasets: [{ label: "Crypto Realtime Price", data: cryptoData }] },
                options: { responsive: true }
            });

            const prediction = await getAIPrediction(cryptoData);
            console.log("Parsed AI Prediction:", prediction);
            renderPredictionChart(prediction);
        }

        function renderPredictionChart(prediction) {
    if (!prediction) return;

    const lastPrice = window.chart.data.datasets[0].data.slice(-1)[0].c;
    const stepSize = (prediction.targetPrice - lastPrice) / prediction.candleCount; // Bagi rata kenaikan/turunannya

    let index = 0;
    function addGhostCandle() {
        if (index >= prediction.candleCount) return;

        const newClose = lastPrice + stepSize * (index + 1);
        const ghostCandle = {
            x: Date.now() + (index + 1) * 60000,
            o: index === 0 ? lastPrice : lastPrice + stepSize * index,
            h: Math.max(lastPrice, newClose),
            l: Math.min(lastPrice, newClose),
            c: newClose
        };

        if (!window.chart.data.datasets.find(ds => ds.label === "AI Prediction")) {
            window.chart.data.datasets.push({
                label: "AI Prediction",
                data: [],
                borderColor: "rgba(255, 99, 132, 0.8)",
                backgroundColor: "rgba(255, 99, 132, 0.3)",
                borderWidth: 2,
                borderDash: [5, 5],  // Garis putus-putus untuk efek prediksi
            });
        }

        const predictionDataset = window.chart.data.datasets.find(ds => ds.label === "AI Prediction");
        predictionDataset.data.push(ghostCandle);
        window.chart.update();

        index++;
        setTimeout(addGhostCandle, 12);
    }

    addGhostCandle();
}

function clearGhostCandles() {
    const predictionDataset = window.chart.data.datasets.find(ds => ds.label === "AI Prediction");
    if (predictionDataset) {
        function removeNextGhostCandle() {
            if (predictionDataset.data.length === 0) return;
            predictionDataset.data.pop(); // Hapus satu per satu dari akhir
            window.chart.update();
            setTimeout(removeNextGhostCandle, 500);
        }
        removeNextGhostCandle();
    }
}

document.getElementById("timeframe").addEventListener("change", () => {
    clearGhostCandles();
    setTimeout(renderChart, 1000); // Tunggu sebentar sebelum merender ulang
});

renderChart();
setInterval(renderChart, 10000);

        
        document.getElementById("crypto").addEventListener("change", renderChart);
        fetchCryptoList().then(() => renderChart()); // Setelah daftar crypto siap, langsung render chart pertama kali
        
        


    </script>
</body>
</html>
