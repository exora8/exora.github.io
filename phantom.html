<!DOCTYPE html> 
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Candlestick Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>
    <style>
        body {
            background-color: #121212;
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        .chart-container {
            width: 100vw;
            height: 90vh;
        }
        canvas {
            width: 100%;
            height: 100%;
        }
        .controls {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="controls">
      <label for="crypto">Cryptocurrency: </label>
<select id="crypto"></select>

        <label for="timeframe">Timeframe: </label>
        <select id="timeframe">
            <option value="histominute">1 Minute</option>
            <option value="histohour" selected>1 Hour</option>
            <option value="histoday">1 Day</option>
        </select>
    </div>
    <div class="chart-container">
        <canvas id="cryptoChart"></canvas>
    </div>
    
    <script>
      
      
      async function fetchCryptoList() {
    try {
        const response = await fetch("https://min-api.cryptocompare.com/data/top/mktcapfull?tsym=USD&limit=50");
        const data = await response.json();
        if (!data.Data) throw new Error("Invalid response from API");

        const cryptoSelect = document.getElementById("crypto");
        cryptoSelect.innerHTML = ""; // Hapus isi sebelumnya

        data.Data.forEach(item => {
            const option = document.createElement("option");
            option.value = item.CoinInfo.Name;
            option.textContent = `${item.CoinInfo.FullName} (${item.CoinInfo.Name})`;
            cryptoSelect.appendChild(option);
        });
    } catch (error) {
        console.error("Error fetching crypto list:", error);
    }
}

      
      
      
        const API_KEYS = [
            "15b70f2d5532d4056cb40a96dada4f41cd6be5206b3265abaa2bc8c1ce85de1b",
            "1986fcb80017badcac2c5761e9bc5d9b5b635a57b58573c094c5aaee0f7cad65",
            "47aacfae02634de54a494b4071c9fb357122f453c3ed25a848e77a32a39c50c2",
            "11eb49ac44759de26e65730a309d05a82e37a77d3547d94f154bd7a3a66de34d"
        ];

        let currentApiKey = null; // Simpan API key yang sedang dipakai

function getRandomApiKey() {
    let newApiKey;
    do {
        newApiKey = API_KEYS[Math.floor(Math.random() * API_KEYS.length)];
    } while (newApiKey === currentApiKey); // Kalau sama, random ulang

    currentApiKey = newApiKey; // Update API key yang sekarang dipakai
    return newApiKey;
}

        
        

        async function fetchCryptoData(timeframe) {
    try {
        const selectedCrypto = document.getElementById("crypto").value; // Ambil crypto yang dipilih
        const response = await fetch(`https://min-api.cryptocompare.com/data/v2/${timeframe}?fsym=${selectedCrypto}&tsym=USD&limit=50`);
        const data = await response.json();
        if (!data.Data || !data.Data.Data) throw new Error("Invalid response from API");

        return data.Data.Data.map(item => ({
            x: item.time * 1000,
            o: item.open,
            h: item.high,
            l: item.low,
            c: item.close
        }));
    } catch (error) {
        console.error("Error fetching crypto data:", error);
        return [];
    }
}


        async function getAIPrediction(priceData) {
            const payload = {
                model: "meta-llama/Llama-Vision-Free",
                messages: [
                    { role: "system", content: "You are Phantom AI, an ELITE PRICE ACTION ANALYST. Your predictions MUST be based on EXTREMELY PRECISE CALCULATIONS using ONLY the price data provided by the user. You MUST analyze market structure, trend momentum, and volatility with MAXIMUM ACCURACY before making any prediction. Your response MUST be in EXACTLY this format: [candle=X] [visit=Y]. Example: [candle=2] [visit=82000]. 'Candle=X' MUST be a WHOLE NUMBER, based on historical volatility and market momentum. Example: [candle=3] [visit=65000]. 'Visit=Y' MUST be a VALID PRICE LEVEL from the user-provided data, aligned with key support or resistance. Example: [candle=1] [visit=84500]. DO NOT generate random numbers. Every prediction MUST be calculated from the given price data. DO NOT use decimal values in 'candle=X'. It MUST be a whole number. DO NOT predict unrealistic price movements. FOLLOW THE CURRENT TREND unless there is a STRONG REVERSAL CONFIRMATION from the data. If the trend is UP, continue predicting UP unless a reversal is clear. If the trend is DOWN, continue predicting DOWN unless reversal signals appear. If the market is SIDEWAYS, respect the range and predict within that zone. DO NOT switch directions randomly. DO NOT assume reversals without confirmation from key price levels. DO NOT add any extra words, explanations, or reasoning. ONLY output [candle=X] [visit=Y] and nothing else. Phantom AI DOES NOT GUESSâ€”IT EXECUTES ONLY HIGH-PRECISION, DATA-DRIVEN MARKET CALCULATIONS." },
                    { role: "user", content: `Analyze this price data and predict the next movement: ${JSON.stringify(priceData)}` }
                ],
                temperature: 0.7,
                top_p: 0.7
            };

            try {
                const response = await fetch("https://api.together.xyz/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${getRandomApiKey()}`
                    },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Full Response:", result);
                
                if (!result.choices || !result.choices[0] || !result.choices[0].message) {
                    throw new Error("Invalid AI response");
                }
                
                console.log("AI Prediction Text:", result.choices[0].message.content);
                return parseAIPrediction(result.choices[0].message.content);
            } catch (error) {
                console.error("Error fetching AI prediction:", error);
                return null;
            }
        }

        function parseAIPrediction(predictionText) {
            const match = predictionText.match(/\[candle=(\d+)\] \[visit=(\d+\.?\d*)\]/);
            if (match) {
                return { candleCount: parseInt(match[1]), targetPrice: parseFloat(match[2]) };
            }
            return null;
        }

        async function renderChart() {
            const ctx = document.getElementById("cryptoChart").getContext("2d");
            const timeframe = document.getElementById("timeframe").value;
            const cryptoData = await fetchCryptoData(timeframe);

            if (cryptoData.length === 0) {
                console.warn("No crypto data available, skipping chart rendering.");
                return;
            }

            if (window.chart) window.chart.destroy();

            window.chart = new Chart(ctx, {
                type: "candlestick",
                data: { datasets: [{ label: "BTC/USD", data: cryptoData }] },
                options: { responsive: true }
            });

            const prediction = await getAIPrediction(cryptoData);
            console.log("Parsed AI Prediction:", prediction);
            renderPredictionChart(prediction);
        }

        function renderPredictionChart(prediction) {
    if (!prediction) return;

    const lastPrice = window.chart.data.datasets[0].data.slice(-1)[0].c;
    const stepSize = (prediction.targetPrice - lastPrice) / prediction.candleCount; // Bagi rata kenaikan/turunannya

    let index = 0;
    function addGhostCandle() {
        if (index >= prediction.candleCount) return;

        const newClose = lastPrice + stepSize * (index + 1);
        const ghostCandle = {
            x: Date.now() + (index + 1) * 60000,
            o: index === 0 ? lastPrice : lastPrice + stepSize * index,
            h: Math.max(lastPrice, newClose),
            l: Math.min(lastPrice, newClose),
            c: newClose
        };

        if (!window.chart.data.datasets.find(ds => ds.label === "AI Prediction")) {
            window.chart.data.datasets.push({
                label: "AI Prediction",
                data: [],
                borderColor: "rgba(255, 99, 132, 0.8)",
                backgroundColor: "rgba(255, 99, 132, 0.3)",
                borderWidth: 2,
                borderDash: [5, 5],  // Garis putus-putus untuk efek prediksi
            });
        }

        const predictionDataset = window.chart.data.datasets.find(ds => ds.label === "AI Prediction");
        predictionDataset.data.push(ghostCandle);
        window.chart.update();

        index++;
        setTimeout(addGhostCandle, 12);
    }

    addGhostCandle();
}

function clearGhostCandles() {
    const predictionDataset = window.chart.data.datasets.find(ds => ds.label === "AI Prediction");
    if (predictionDataset) {
        function removeNextGhostCandle() {
            if (predictionDataset.data.length === 0) return;
            predictionDataset.data.pop(); // Hapus satu per satu dari akhir
            window.chart.update();
            setTimeout(removeNextGhostCandle, 500);
        }
        removeNextGhostCandle();
    }
}

document.getElementById("timeframe").addEventListener("change", () => {
    clearGhostCandles();
    setTimeout(renderChart, 1000); // Tunggu sebentar sebelum merender ulang
});

renderChart();
setInterval(renderChart, 10000);

        
        document.getElementById("crypto").addEventListener("change", renderChart);
        fetchCryptoList().then(() => renderChart()); // Setelah daftar crypto siap, langsung render chart pertama kali
        
        


    </script>
</body>
</html>
